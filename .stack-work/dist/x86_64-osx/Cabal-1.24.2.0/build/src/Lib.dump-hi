
==================== FINAL INTERFACE ====================
2017-12-10 12:53:45.73418 UTC

interface words-0.1.0.0-2BohWveyA5lK0ewgybZufq:Lib 8002
  interface hash: 2af89939825f1dd7b125998463cbf3e9
  ABI hash: 10fc7f4b0f2dae6243e08fe3a4dc63ed
  export-list hash: c893ae80ea3a4d69054957a02612b600
  orphan hash: cce5b68f639e1f5991b5b65c02350761
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.cell2char
  Lib.completed
  Lib.findWord
  Lib.findWordInCellLinePrefix
  Lib.findWordInLine
  Lib.findWords
  Lib.formatGame
  Lib.formatGrid
  Lib.gridWithCoords
  Lib.makeGame
  Lib.outputGrid
  Lib.playGame
  Lib.score
  Lib.skew
  Lib.totalWords
  Lib.zipOverGrid
  Lib.zipOverGridWith
  Lib.Cell{Lib.Cell Lib.Indent}
  Lib.Game{gameGrid gameWords}
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 0fd5c8559af8bc4b6f38b9cf9ba5a467
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base 8b155a212edaca6c85bcefe65a8bc505
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  integer-gmp-1.0.0.1:GHC.Integer.Type 318df275d77dcdb18e0006d8d7870c2a
54286c75518fad41f009f50a0ca202b3
  $fEqCell :: GHC.Classes.Eq Lib.Cell
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ Lib.Cell Lib.$fEqCell_$c== Lib.$fEqCell_$c/= -}
54286c75518fad41f009f50a0ca202b3
  $fEqCell_$c/= :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case Lib.$fEqCell_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
54286c75518fad41f009f50a0ca202b3
  $fEqCell_$c== :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Lib.Cell) (ds1 :: Lib.Cell) ->
                 case ds of wild {
                   Lib.Cell a1 a2
                   -> case ds1 of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.eqInteger# ww1 ww4 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Integer.Type.eqInteger# ww2 ww5 of wild4 { DEFAULT ->
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True -> GHC.Classes.eqChar a2 b2 } } } } } }
                        Lib.Indent -> GHC.Types.False }
                   Lib.Indent
                   -> case ds1 of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.False
                        Lib.Indent -> GHC.Types.True } }) -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell :: GHC.Classes.Ord Lib.Cell
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Cell
                  Lib.$fEqCell
                  Lib.$fOrdCell_$ccompare
                  Lib.$fOrdCell_$c<
                  Lib.$fOrdCell_$c<=
                  Lib.$fOrdCell_$c>
                  Lib.$fOrdCell_$c>=
                  Lib.$fOrdCell_$cmax
                  Lib.$fOrdCell_$cmin -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell_$c< :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.True
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c< a2 b2
                                  GHC.Types.GT -> GHC.Types.False }
                             GHC.Types.GT -> GHC.Types.False } } }
                        Lib.Indent -> GHC.Types.True }
                   Lib.Indent -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell_$c<= :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.True
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c<= a2 b2
                                  GHC.Types.GT -> GHC.Types.False }
                             GHC.Types.GT -> GHC.Types.False } } }
                        Lib.Indent -> GHC.Types.True }
                   Lib.Indent
                   -> case b of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.False
                        Lib.Indent -> GHC.Types.True } }) -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell_$c> :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.False
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c> a2 b2
                                  GHC.Types.GT -> GHC.Types.True }
                             GHC.Types.GT -> GHC.Types.True } } }
                        Lib.Indent -> GHC.Types.False }
                   Lib.Indent
                   -> case b of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.True
                        Lib.Indent -> GHC.Types.False } }) -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell_$c>= :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.False
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c>= a2 b2
                                  GHC.Types.GT -> GHC.Types.True }
                             GHC.Types.GT -> GHC.Types.True } } }
                        Lib.Indent -> GHC.Types.False }
                   Lib.Indent -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell_$ccompare :: Lib.Cell -> Lib.Cell -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.LT
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$ccompare a2 b2
                                  GHC.Types.GT -> GHC.Types.GT }
                             GHC.Types.GT -> GHC.Types.GT } } }
                        Lib.Indent -> GHC.Types.LT }
                   Lib.Indent
                   -> case b of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.GT
                        Lib.Indent -> GHC.Types.EQ } }) -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell_$cmax :: Lib.Cell -> Lib.Cell -> Lib.Cell
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: Lib.Cell) (y :: Lib.Cell) ->
                 case Lib.$fOrdCell_$c<= x1 y of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> y }) -}
54286c75518fad41f009f50a0ca202b3
  $fOrdCell_$cmin :: Lib.Cell -> Lib.Cell -> Lib.Cell
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: Lib.Cell) (y :: Lib.Cell) ->
                 case Lib.$fOrdCell_$c<= x1 y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x1 }) -}
54286c75518fad41f009f50a0ca202b3
  $fShowCell :: GHC.Show.Show Lib.Cell
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Cell
                  Lib.$fShowCell_$cshowsPrec
                  Lib.$fShowCell_$cshow
                  Lib.$fShowCell_$cshowList -}
54286c75518fad41f009f50a0ca202b3
  $fShowCell1 :: Lib.Cell -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Lib.$fShowCell_$cshowsPrec Lib.$fShowCell2) -}
106966790000a14d6a3d3f1fb9680710
  $fShowCell2 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
e417c207500ab95ec6be3bb7ea081218
  $fShowCell3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Indent"#) -}
f3988a11c7d5b92fbfa5ee3503e2a8a9
  $fShowCell4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Cell "#) -}
54286c75518fad41f009f50a0ca202b3
  $fShowCell_$cshow :: Lib.Cell -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Lib.Cell) ->
                 Lib.$fShowCell_$cshowsPrec
                   GHC.Show.shows22
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
54286c75518fad41f009f50a0ca202b3
  $fShowCell_$cshowList :: [Lib.Cell] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Cell Lib.$fShowCell1) -}
54286c75518fad41f009f50a0ca202b3
  $fShowCell_$cshowsPrec ::
    GHC.Types.Int -> Lib.Cell -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (a :: GHC.Types.Int)
                   (ds :: Lib.Cell)
                   (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Lib.Cell b1 b2
                   -> case a of wild1 { GHC.Types.I# x1 ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x2 :: GHC.Base.String)[OneShot] ->
                          case b1 of ww { (,) ww1 ww2 ->
                          GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows7
                            (case GHC.Show.$w$cshowsPrec1
                                    0#
                                    ww1
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.shows5
                                       (GHC.Show.$fShow(,)_$sgo
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.shows4
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.showSpace1
                                                (case b2 of ww4 { GHC.Types.C# ww5 ->
                                                 case ww5 of ds1 {
                                                   DEFAULT
                                                   -> GHC.Types.:
                                                        @ GHC.Types.Char
                                                        GHC.Show.shows14
                                                        (GHC.Show.$wshowLitChar
                                                           ds1
                                                           (GHC.Types.:
                                                              @ GHC.Types.Char
                                                              GHC.Show.shows14
                                                              x2))
                                                   '\''#
                                                   -> GHC.Base.++
                                                        @ GHC.Types.Char
                                                        GHC.Show.shows13
                                                        x2 } })))
                                          (\ (w2 :: GHC.Base.String) ->
                                           case GHC.Show.$w$cshowsPrec1
                                                  0#
                                                  ww2
                                                  w2 of ww4 { (#,#) ww3 ww5 ->
                                           GHC.Types.: @ GHC.Types.Char ww3 ww5 })
                                          (GHC.Types.[]
                                             @ GHC.Show.ShowS))) of ww4 { (#,#) ww3 ww5 ->
                             GHC.Types.: @ GHC.Types.Char ww3 ww5 }) }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x1 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowCell4 (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Lib.$fShowCell4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 eta))) } }
                   Lib.Indent
                   -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowCell3 eta }) -}
76e1c48c953eb4187ca8ddb7b6571306
  $fShowGame :: GHC.Show.Show Lib.Game
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Game
                  Lib.$fShowGame_$cshowsPrec
                  Lib.$fShowGame_$cshow
                  Lib.$fShowGame_$cshowList -}
76e1c48c953eb4187ca8ddb7b6571306
  $fShowGame1 :: Lib.Game -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 ->
                 Lib.$w$cshowsPrec 0# ww1 ww2 }) -}
76e1c48c953eb4187ca8ddb7b6571306
  $fShowGame_$cshow :: Lib.Game -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Lib.Game) ->
                 Lib.$fShowGame_$cshowsPrec
                   GHC.Show.shows22
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
76e1c48c953eb4187ca8ddb7b6571306
  $fShowGame_$cshowList :: [Lib.Game] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Game Lib.$fShowGame1) -}
76e1c48c953eb4187ca8ddb7b6571306
  $fShowGame_$cshowsPrec ::
    GHC.Types.Int -> Lib.Game -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Game) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Game ww3 ww4 ->
                 Lib.$w$cshowsPrec ww1 ww3 ww4 } }) -}
0891c33433e0399b295a664815c84a52
  $s$fShowMap_$cshowsPrec1 :: GHC.Show.Show [Lib.Cell]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Lib.$s$fShowMap_$cshowsPrec_$s$fShow[] -}
5c1589672a2d11bce296adb6aa006190
  $s$fShowMap_$cshowsPrec_$s$fShowMaybe ::
    GHC.Show.Show (GHC.Base.Maybe [Lib.Cell])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe [Lib.Cell])
                  (GHC.Show.$fShowMaybe_$cshowsPrec
                     @ [Lib.Cell]
                     Lib.$s$fShowMap_$cshowsPrec1)
                  (GHC.Show.$fShowMaybe_$cshow
                     @ [Lib.Cell]
                     Lib.$s$fShowMap_$cshowsPrec1)
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShowMaybe_$cshowList -}
aae409f688d7b82babf0c40061c65788
  $s$fShowMap_$cshowsPrec_$s$fShowMaybe_$cshowList ::
    [GHC.Base.Maybe [Lib.Cell]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [GHC.Base.Maybe [Lib.Cell]])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Base.Maybe [Lib.Cell])
                   (GHC.Show.$fShowMaybe_$cshowsPrec
                      @ [Lib.Cell]
                      Lib.$s$fShowMap_$cshowsPrec1
                      GHC.Show.shows22)
                   eta
                   eta1) -}
b39adcba06fdd00f96141ada502262eb
  $s$fShowMap_$cshowsPrec_$s$fShow[] :: GHC.Show.Show [Lib.Cell]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [Lib.Cell]
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowsPrec
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshow
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowList -}
9e57d007c7757627f03cfa29acc3c55d
  $s$fShowMap_$cshowsPrec_$s$fShow[]_$cshow ::
    [Lib.Cell] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: [Lib.Cell]) ->
                 Lib.$fShowCell_$cshowList x1 (GHC.Types.[] @ GHC.Types.Char)) -}
0c11e62e3a7b207853bef135cce598b7
  $s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowList ::
    [[Lib.Cell]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [[Lib.Cell]]) (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ [Lib.Cell]
                   Lib.$fShowCell_$cshowList
                   eta
                   eta1) -}
e242168349a1e61acf3af2acde393d90
  $s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowsPrec ::
    GHC.Types.Int -> [Lib.Cell] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Int)
                   (eta :: [Lib.Cell])
                   (eta1 :: GHC.Base.String) ->
                 Lib.$fShowCell_$cshowList eta eta1) -}
e32c0a1ef103f921df919658af3f1185
  $sfromList ::
    [(GHC.Base.String, a)] -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(GHC.Base.String, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ GHC.Base.String @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x1 ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Base.Bin
                             @ GHC.Base.String
                             @ a
                             1#
                             dt
                             x1
                             (Data.Map.Base.Tip @ GHC.Base.String @ a)
                             (Data.Map.Base.Tip @ GHC.Base.String @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$s$ccompare1 kx ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                Lib.$sfromList1
                                  @ a
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x1
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a))
                                  wild2 }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                Lib.$wpoly_go10
                                  @ a
                                  1#
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x1
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a))
                                  wild2 } } } } } }) -}
078665eb54128a4da9610b0e41274732
  $sfromList1 ::
    Data.Map.Base.Map GHC.Base.String a1
    -> [(GHC.Base.String, a1)] -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
ffc1892954bbab6defcb419625faa2e0
  $sinsert_$sgo10 ::
    GHC.Base.String
    -> a1
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
e15055795caa735e846bb0550b43efa9
  $smember1 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e0fdce2c24971a989911311ccff46466
  $tc'Cell :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8163202596668834071##
                   5649522107347401093##
                   Lib.$trModule
                   Lib.$tc'Cell1) -}
01e332d61a55ef3fc895fee6343d5a26
  $tc'Cell1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Cell"#) -}
deda392916c38ef7f842c9abe2057a31
  $tc'Game :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8488147691251398787##
                   6460787314886583866##
                   Lib.$trModule
                   Lib.$tc'Game1) -}
e34d2a368ba45622d84cd5f827a00d08
  $tc'Game1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Game"#) -}
1efe460c2f5ca035d09cf746b5b06001
  $tc'Indent :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14981915159195520151##
                   14612397704369797449##
                   Lib.$trModule
                   Lib.$tc'Indent1) -}
4f2ec1a216a9f528792190bef2db093f
  $tc'Indent1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Indent"#) -}
43c1d6775802daf1431bb3f96281dcd6
  $tcCell :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12049302456649562124##
                   4858577557709471604##
                   Lib.$trModule
                   Lib.$tcCell1) -}
77a62b0f5a10f91d3143b222a9db4972
  $tcCell1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Cell"#) -}
a71da1ce7f345cadfd070a4ec51b88af
  $tcGame :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7985521512939939643##
                   6730718840303368741##
                   Lib.$trModule
                   Lib.$tcGame1) -}
586fe7f3930b685d247a8971a326256e
  $tcGame1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Game"#) -}
3e360d14ba3044bacdbe7daf15272fef
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
506d1bd9ab9a3f75ef8adb7a62567d57
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
7c47b7ecc6880cca959f71c1637de0bc
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "words-0.1.0.0-2BohWveyA5lK0ewgybZufq"#) -}
4519b904a0b2b9229b4c93dd0e55d856
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Lib.Grid Lib.Cell
    -> Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,U><L,1*U>, Inline: [0] -}
506c907e0fabcbb757d8c7e29163c51f
  $wcompleted ::
    Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: Data.Map.Base.Map
                            GHC.Base.String (GHC.Base.Maybe [Lib.Cell])) ->
                 case GHC.List.$wlenAcc
                        @ [Lib.Cell]
                        (Data.Maybe.catMaybes1
                           @ [Lib.Cell]
                           (Data.Map.Base.elems
                              @ [GHC.Types.Char]
                              @ (GHC.Base.Maybe [Lib.Cell])
                              ww))
                        0# of ww2 { DEFAULT ->
                 case Lib.completed_go10
                        (GHC.Base.id @ GHC.Types.Int)
                        ww
                        Lib.$fShowCell2 of wild1 { GHC.Types.I# y ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ww2 y) } }) -}
9b741a53e1308ba203b0fa421063677c
  $wformatGame ::
    Lib.Grid Lib.Cell
    -> Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: Lib.Grid Lib.Cell)
                   (ww1 :: Data.Map.Base.Map
                             GHC.Base.String (GHC.Base.Maybe [Lib.Cell])) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Data.OldList.unlines
                      (GHC.Base.map @ [Lib.Cell] @ [GHC.Types.Char] Lib.formatGame1 ww))
                   (GHC.CString.unpackAppendCString#
                      "\n\
                      \\n"#
                      (case GHC.List.$wlenAcc
                              @ [Lib.Cell]
                              (Data.Maybe.catMaybes1
                                 @ [Lib.Cell]
                                 (Data.Map.Base.elems
                                    @ [GHC.Types.Char]
                                    @ (GHC.Base.Maybe [Lib.Cell])
                                    ww1))
                              0# of ww2 { DEFAULT ->
                       case GHC.Show.$wshowSignedInt
                              0#
                              ww2
                              (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                       GHC.Base.++
                         @ GHC.Types.Char
                         (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                         (GHC.CString.unpackAppendCString#
                            "/"#
                            (case Lib.completed_go10
                                    (GHC.Base.id @ GHC.Types.Int)
                                    ww1
                                    Lib.$fShowCell2 of ww3 { GHC.Types.I# ww7 ->
                             case GHC.Show.$wshowSignedInt
                                    0#
                                    ww7
                                    (GHC.Types.[] @ GHC.Types.Char) of ww8 { (#,#) ww9 ww10 ->
                             GHC.Types.: @ GHC.Types.Char ww9 ww10 } })) } }))) -}
1554530b0d8c1458cf73014a75386850
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Base.String a
    -> [(GHC.Base.String, a)]
    -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
54286c75518fad41f009f50a0ca202b3
  data Cell
    = Cell (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
           GHC.Types.Char
    | Indent
76e1c48c953eb4187ca8ddb7b6571306
  data Game
    = Game {gameGrid :: Lib.Grid Lib.Cell,
            gameWords :: Data.Map.Base.Map
                           GHC.Base.String (GHC.Base.Maybe [Lib.Cell])}
76c3c693f523da28017d111df4994776
  type Grid a = [[a]]
2da723161d848a75c70bd5c869a7130f
  cell2char :: Lib.Cell -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Cell) ->
                 case ds of wild {
                   Lib.Cell ds1 c -> c Lib.Indent -> Lib.cell2char1 }) -}
956a752bb0adbd001c4fbdbc6bce09a1
  cell2char1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '?'#) -}
cb1573412bb45b958f7b8f3e572720ff
  completed :: Lib.Game -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 -> Lib.$wcompleted ww2 }) -}
3609a362f7ca87609efaed4c59aef9b6
  completed_go10 ::
    (GHC.Types.Int -> GHC.Types.Int)
    -> Data.Map.Base.Map [GHC.Types.Char] (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
500e2b5c3ac9e4d01a575eefe3b63b2e
  findWord ::
    Lib.Grid Lib.Cell -> GHC.Base.String -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (grid :: Lib.Grid Lib.Cell)
                   (word :: GHC.Base.String) ->
                 let {
                   lines :: [[Lib.Cell]]
                   = GHC.Base.++
                       @ [Lib.Cell]
                       grid
                       (GHC.Base.++
                          @ [Lib.Cell]
                          (Data.OldList.transpose @ Lib.Cell grid)
                          (GHC.Base.++
                             @ [Lib.Cell]
                             (Data.OldList.transpose @ Lib.Cell (Lib.skew grid))
                             (Data.OldList.transpose
                                @ Lib.Cell
                                (Lib.skew
                                   (GHC.Base.map
                                      @ [Lib.Cell]
                                      @ [Lib.Cell]
                                      (GHC.List.reverse @ Lib.Cell)
                                      grid)))))
                 } in
                 let {
                   z :: [GHC.Base.Maybe [Lib.Cell]]
                   = GHC.Base.map
                       @ [Lib.Cell]
                       @ (GHC.Base.Maybe [Lib.Cell])
                       (\ (x1 :: [Lib.Cell]) ->
                        Lib.findWordInLine word (GHC.List.reverse @ Lib.Cell x1))
                       lines
                 } in
                 letrec {
                   go :: [[Lib.Cell]] -> [GHC.Base.Maybe [Lib.Cell]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[Lib.Cell]]) ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> GHC.Types.:
                            @ (GHC.Base.Maybe [Lib.Cell])
                            (Lib.findWordInLine word y)
                            (go ys) }
                 } in
                 case Data.Maybe.catMaybes1 @ [Lib.Cell] (go lines) of wild {
                   [] -> GHC.Base.Nothing @ [Lib.Cell]
                   : a1 ds1 -> GHC.Base.Just @ [Lib.Cell] a1 }) -}
2657599103d1de8ed047f33aa07ce4c8
  findWordInCellLinePrefix ::
    [Lib.Cell]
    -> GHC.Base.String -> [Lib.Cell] -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,1*U> -}
891706b9da08e1b86d047f63148c3bd6
  findWordInLine ::
    GHC.Base.String -> [Lib.Cell] -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
a7cd75834e94cb281a8ca07657d39318
  findWords ::
    Lib.Grid Lib.Cell -> [GHC.Base.String] -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (grid :: Lib.Grid Lib.Cell)
                   (words :: [GHC.Base.String]) ->
                 case Data.Maybe.catMaybes1
                        @ [Lib.Cell]
                        (GHC.Base.map
                           @ [GHC.Types.Char]
                           @ (GHC.Base.Maybe [Lib.Cell])
                           (Lib.findWord grid)
                           words) of wild {
                   [] -> GHC.Base.Nothing @ [Lib.Cell]
                   : a1 ds1 -> GHC.Base.Just @ [Lib.Cell] a1 }) -}
ac630098badcfd52eda8cd06da5a6f17
  formatGame :: Lib.Game -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 -> Lib.$wformatGame ww1 ww2 }) -}
3446810e1d2ab5dc4b6cb9036f73767c
  formatGame1 :: [Lib.Cell] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.Base.map
                   @ Lib.Cell
                   @ GHC.Types.Char
                   Lib.cell2char) -}
e5cdef07fd6c5fcc8b3dfb6e02792679
  formatGrid :: Lib.Grid Lib.Cell -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Lib.Grid Lib.Cell) ->
                 Data.OldList.unlines
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         (c :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ [Lib.Cell]
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ [Lib.Cell]
                            c
                            Lib.formatGame1)
                         n
                         x1))) -}
9ec4117dd9b6415b9c177ede55e92a60
  gameGrid :: Lib.Game -> Lib.Grid Lib.Cell
  RecSel Left Lib.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Game) ->
                 case ds of wild { Lib.Game ds1 ds2 -> ds1 }) -}
12b8d88aa7a02153b51392a2b38c57ef
  gameWords ::
    Lib.Game
    -> Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
  RecSel Left Lib.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Game) ->
                 case ds of wild { Lib.Game ds1 ds2 -> ds2 }) -}
e9b1d1aeafb6535af548b93e50fda601
  gridWithCoords :: Lib.Grid GHC.Types.Char -> Lib.Grid Lib.Cell
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [[GHC.Types.Char]]) ->
                 GHC.Base.build
                   @ [Lib.Cell]
                   (\ @ b1
                      (c1 :: [Lib.Cell] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.List.zipWithFB
                         @ [Lib.Cell]
                         @ b1
                         @ b1
                         @ [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                         @ [GHC.Types.Char]
                         c1
                         (GHC.List.zipWith
                            @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                            @ GHC.Types.Char
                            @ Lib.Cell
                            Lib.Cell))
                      n
                      Lib.gridWithCoords1
                      eta)) -}
54b691101da2959f9bcffd43f878e5d2
  gridWithCoords1 ::
    [[(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]]
  {- Unfolding: (Lib.gridWithCoords_go
                   Lib.gridWithCoords2
                   Lib.gridWithCoords_xs) -}
dd0f05dbd6385cf1106b21dd98e61064
  gridWithCoords2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
a3585345002dfc73ae5636ac60510626
  gridWithCoords_go ::
    GHC.Integer.Type.Integer
    -> [[GHC.Integer.Type.Integer]]
    -> [[(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
529da69a1e34d1622ca6e537f456168a
  gridWithCoords_xs :: [[GHC.Integer.Type.Integer]]
8f186f50ee16bf3e6c52014e0caf28f2
  makeGame ::
    Lib.Grid GHC.Types.Char -> [GHC.Base.String] -> Lib.Game
  {- Arity: 2, Strictness: <L,1*U><L,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid GHC.Types.Char)
                   (words :: [GHC.Base.String]) ->
                 Lib.Game
                   (Lib.gridWithCoords grid)
                   (Lib.$sfromList
                      @ (GHC.Base.Maybe [Lib.Cell])
                      (GHC.Base.build
                         @ (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
                         (\ @ b1
                            (c :: (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
                                  -> b1 -> b1)[OneShot]
                            (n :: b1)[OneShot] ->
                          GHC.Base.foldr
                            @ [GHC.Types.Char]
                            @ b1
                            (GHC.Base.mapFB
                               @ (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
                               @ b1
                               @ [GHC.Types.Char]
                               c
                               Lib.makeGame1)
                            n
                            words)))) -}
9cd3613bd36ac570b32aaee8062cee1d
  makeGame1 ::
    GHC.Base.String -> (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (word :: GHC.Base.String) ->
                 (word, GHC.Base.Nothing @ [Lib.Cell])) -}
07c612f8261121dfe56cec50d9b22147
  outputGrid :: Lib.Grid Lib.Cell -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.outputGrid1
                  `cast`
                (<Lib.Grid Lib.Cell>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
8b1d6c23c8bd900be80457c145f945e1
  outputGrid1 ::
    Lib.Grid Lib.Cell
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid Lib.Cell)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Lib.formatGrid grid)
                   GHC.Types.True
                   eta) -}
126a9ab87c8fc7e795bd14e6399e23d0
  playGame :: Lib.Game -> GHC.Base.String -> Lib.Game
  {- Arity: 2, Strictness: <S(LS),1*U(U,U)><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Game) (w1 :: GHC.Base.String) ->
                 case w of ww { Lib.Game ww1 ww2 ->
                 case Lib.$smember1 @ (GHC.Base.Maybe [Lib.Cell]) w1 ww2 of wild {
                   GHC.Types.False -> Lib.Game ww1 ww2
                   GHC.Types.True
                   -> case Lib.findWord ww1 w1 of wild1 {
                        GHC.Base.Nothing -> Lib.Game ww1 ww2
                        GHC.Base.Just cs
                        -> Lib.Game
                             ww1
                             (Lib.$sinsert_$sgo10
                                @ (GHC.Base.Maybe [Lib.Cell])
                                w1
                                wild1
                                ww2) } } }) -}
9efd1093058d9a2b8d736f038e398f52
  score :: Lib.Game -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 ->
                 case GHC.List.$wlenAcc
                        @ [Lib.Cell]
                        (Data.Maybe.catMaybes1
                           @ [Lib.Cell]
                           (Data.Map.Base.elems
                              @ [GHC.Types.Char]
                              @ (GHC.Base.Maybe [Lib.Cell])
                              ww2))
                        0# of ww3 { DEFAULT ->
                 GHC.Types.I# ww3 } }) -}
18fae13dc0f9715558f830f3b8b4d714
  skew :: Lib.Grid Lib.Cell -> Lib.Grid Lib.Cell
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
2ed870a449563f1988efcd865a1441d4
  totalWords :: Lib.Game -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (game :: Lib.Game) ->
                 case game of wild { Lib.Game ds ds1 -> Lib.totalWords1 ds1 }) -}
7986c04c66518ba3b7e48e6640e1f095
  totalWords1 ::
    Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (x1 :: Data.Map.Base.Map
                            GHC.Base.String (GHC.Base.Maybe [Lib.Cell])) ->
                 Lib.completed_go10
                   (GHC.Base.id @ GHC.Types.Int)
                   x1
                   Lib.$fShowCell2) -}
bc5d12919976b9ef5d97546a18ce478c
  zipOverGrid :: Lib.Grid a -> Lib.Grid b -> Lib.Grid (a, b)
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ @ a @ b ->
                 GHC.List.zipWith @ [a] @ [b] @ [(a, b)] (GHC.List.zip @ a @ b)) -}
524ce482ce7461b9add65b3c757aafd6
  zipOverGridWith ::
    (a -> b -> c) -> Lib.Grid a -> Lib.Grid b -> Lib.Grid c
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (x1 :: a -> b -> c)
                   (eta :: [[a]])
                   (eta1 :: [[b]]) ->
                 GHC.Base.build
                   @ [c]
                   (\ @ b1 (c1 :: [c] -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ [a]
                      @ [b]
                      @ b1
                      (GHC.List.zipWithFB
                         @ [c]
                         @ b1
                         @ b1
                         @ [a]
                         @ [b]
                         c1
                         (GHC.List.zipWith @ a @ b @ c x1))
                      n
                      eta
                      eta1)) -}
instance [safe] GHC.Classes.Eq [Lib.Cell] = Lib.$fEqCell
instance [safe] GHC.Classes.Ord [Lib.Cell] = Lib.$fOrdCell
instance [safe] GHC.Show.Show [Lib.Cell] = Lib.$fShowCell
instance [safe] GHC.Show.Show [Lib.Game] = Lib.$fShowGame
"SPEC/Lib $fShowMaybe @ [Cell]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                             [Lib.Cell])
  GHC.Show.$fShowMaybe @ [Lib.Cell] $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShowMaybe
"SPEC/Lib $fShowMaybe_$cshowList @ [Cell]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                        [Lib.Cell])
  GHC.Show.$fShowMaybe_$cshowList @ [Lib.Cell] $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShowMaybe_$cshowList
"SPEC/Lib $fShow[] @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Lib.Cell)
  GHC.Show.$fShow[] @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]
"SPEC/Lib $fShow[]_$cshow @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                               Lib.Cell)
  GHC.Show.$fShow[]_$cshow @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshow
"SPEC/Lib $fShow[]_$cshowList @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                   Lib.Cell)
  GHC.Show.$fShow[]_$cshowList @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowList
"SPEC/Lib $fShow[]_$cshowsPrec @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                    Lib.Cell)
  GHC.Show.$fShow[]_$cshowsPrec @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowsPrec
"SPEC/Lib fromList @ String _" [ALWAYS] forall @ a
                                               ($dOrd :: GHC.Classes.Ord GHC.Base.String)
  Data.Map.Base.fromList @ [GHC.Types.Char] @ a $dOrd
  = Lib.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

