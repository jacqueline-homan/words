
==================== FINAL INTERFACE ====================
2017-12-04 06:13:02.505863 UTC

interface words-0.1.0.0-CYI3KknegDpJL5eLhQz4hl:Lib 8002
  interface hash: d78f8bf37e94dbd9d000e6a9cb14770e
  ABI hash: d624ed7e6e3a1ced2a9fac6a658b8850
  export-list hash: 318efb8f623c01fb15f9d1edd1eabf2a
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.findWord
  Lib.findWordInLine
  Lib.findWords
  Lib.formatGrid
  Lib.outputGrid
  Lib.skew
module dependencies: Data
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  Data 39bc4c572ce575449c4dbbad891f3e1d
  exports: 73c897f1a14ad8b095cdd6591b02923c
13b784e5afbb489c4624ba8d589df8bb
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
58c6c816bd0ff60c1aa4a21708b4fc83
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
5e1b4f9196524d64b6691e2f7e9a75bd
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "words-0.1.0.0-CYI3KknegDpJL5eLhQz4hl"#) -}
4a1706ec4686064a7a82403896e1b214
  type Grid = [GHC.Base.String]
d3ed0cb584af2dc9f1fe1b1342d20735
  findWord ::
    Lib.Grid -> GHC.Base.String -> GHC.Base.Maybe GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (grid :: Lib.Grid) (word :: GHC.Base.String) ->
                 let {
                   lines :: [GHC.Base.String]
                   = GHC.Base.++
                       @ [GHC.Types.Char]
                       grid
                       (GHC.Base.++
                          @ [GHC.Types.Char]
                          (Data.OldList.transpose @ GHC.Types.Char grid)
                          (GHC.Base.++
                             @ [GHC.Types.Char]
                             (Data.OldList.transpose @ GHC.Types.Char (Lib.skew grid))
                             (Data.OldList.transpose
                                @ GHC.Types.Char
                                (Lib.skew
                                   (GHC.Base.map
                                      @ [GHC.Types.Char]
                                      @ [GHC.Types.Char]
                                      (GHC.List.reverse @ GHC.Types.Char)
                                      grid)))))
                 } in
                 let {
                   z :: Data.Monoid.Any
                   = letrec {
                       go :: [[GHC.Types.Char]] -> Data.Monoid.Any
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [[GHC.Types.Char]]) ->
                         case ds of wild {
                           [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                           : y ys
                           -> case Data.OldList.isInfixOf
                                     @ GHC.Types.Char
                                     GHC.Classes.$fEqChar
                                     word
                                     (GHC.List.reverse @ GHC.Types.Char y) of wild1 {
                                GHC.Types.False -> go ys
                                GHC.Types.True
                                -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } }
                     } in
                     go lines
                 } in
                 letrec {
                   go :: [[GHC.Types.Char]] -> Data.Monoid.Any
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Types.Char]]) ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> case Data.OldList.isInfixOf
                                 @ GHC.Types.Char
                                 GHC.Classes.$fEqChar
                                 word
                                 y of wild1 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } }
                 } in
                 case (go lines) `cast` (Data.Monoid.N:Any[0]) of wild {
                   GHC.Types.False -> GHC.Base.Nothing @ GHC.Base.String
                   GHC.Types.True -> GHC.Base.Just @ GHC.Base.String word }) -}
05f3ade4bdd8b5b9fc830a1df99225bc
  findWordInLine ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (Data.OldList.isInfixOf
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar) -}
0b3e7cba5b1149a4bbb823a6b793066b
  findWords :: Lib.Grid -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid) (words :: [GHC.Base.String]) ->
                 Data.Maybe.catMaybes1
                   @ GHC.Base.String
                   (GHC.Base.build
                      @ (GHC.Base.Maybe GHC.Base.String)
                      (\ @ b1
                         (c :: GHC.Base.Maybe GHC.Base.String -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ [GHC.Types.Char]
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Base.Maybe GHC.Base.String)
                            @ b1
                            @ [GHC.Types.Char]
                            c
                            (Lib.findWord grid))
                         n
                         words))) -}
475ed25e04ceb9c1b7040ad4ce4de1ca
  formatGrid :: Lib.Grid -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) Data.OldList.unlines -}
1ae75a55651dcddc54dec910ee06a5c7
  outputGrid :: Lib.Grid -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.outputGrid1
                  `cast`
                (<Lib.Grid>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
ce33eb31c149af93543e321676dcefee
  outputGrid1 ::
    Lib.Grid
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Data.OldList.unlines grid)
                   GHC.Types.True
                   eta) -}
27901b3aed5c97bf97d3e556dffbf29e
  skew :: Lib.Grid -> Lib.Grid
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

