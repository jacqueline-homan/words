
==================== FINAL INTERFACE ====================
2017-12-10 13:55:18.350517 UTC

interface words-0.1.0.0-LISqhhIiZ4617lGqKY5VXc:Lib 8002
  interface hash: 2b785b151c1c53af1c9c6e4ef1779e5d
  ABI hash: 4e8f53d6c1ce07f940f7016c9737b38d
  export-list hash: dc8c3a05f69e1b92f68a660eb1f62284
  orphan hash: 7fa56b7d3dae50019773f55de8e1369f
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.cell2char
  Lib.completed
  Lib.fillInBlanks
  Lib.findWord
  Lib.findWordInCellLinePrefix
  Lib.findWordInLine
  Lib.findWords
  Lib.formatGame
  Lib.formatGrid
  Lib.gridWithCoords
  Lib.makeGame
  Lib.makeRandomGrid
  Lib.outputGrid
  Lib.playGame
  Lib.score
  Lib.skew
  Lib.totalWords
  Lib.zipOverGrid
  Lib.zipOverGridWith
  Lib.Cell{Lib.Cell Lib.Indent}
  Lib.Game{gameGrid gameWords}
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog*
                      time-1.6.0.1@time-1.6.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 0fd5c8559af8bc4b6f38b9cf9ba5a467
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base 8b155a212edaca6c85bcefe65a8bc505
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  integer-gmp-1.0.0.1:GHC.Integer.Type 318df275d77dcdb18e0006d8d7870c2a
import  -/  random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog:System.Random cc3ef358c669b194cf9fe94db6f2430f
baa386c6efd40b5f3cc6bb5e664afd33
  $fEqCell :: GHC.Classes.Eq Lib.Cell
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ Lib.Cell Lib.$fEqCell_$c== Lib.$fEqCell_$c/= -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fEqCell_$c/= :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case Lib.$fEqCell_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fEqCell_$c== :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Lib.Cell) (ds1 :: Lib.Cell) ->
                 case ds of wild {
                   Lib.Cell a1 a2
                   -> case ds1 of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.eqInteger# ww1 ww4 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Integer.Type.eqInteger# ww2 ww5 of wild4 { DEFAULT ->
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True -> GHC.Classes.eqChar a2 b2 } } } } } }
                        Lib.Indent -> GHC.Types.False }
                   Lib.Indent
                   -> case ds1 of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.False
                        Lib.Indent -> GHC.Types.True } }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell :: GHC.Classes.Ord Lib.Cell
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Cell
                  Lib.$fEqCell
                  Lib.$fOrdCell_$ccompare
                  Lib.$fOrdCell_$c<
                  Lib.$fOrdCell_$c<=
                  Lib.$fOrdCell_$c>
                  Lib.$fOrdCell_$c>=
                  Lib.$fOrdCell_$cmax
                  Lib.$fOrdCell_$cmin -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell_$c< :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.True
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c< a2 b2
                                  GHC.Types.GT -> GHC.Types.False }
                             GHC.Types.GT -> GHC.Types.False } } }
                        Lib.Indent -> GHC.Types.True }
                   Lib.Indent -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell_$c<= :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.True
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c<= a2 b2
                                  GHC.Types.GT -> GHC.Types.False }
                             GHC.Types.GT -> GHC.Types.False } } }
                        Lib.Indent -> GHC.Types.True }
                   Lib.Indent
                   -> case b of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.False
                        Lib.Indent -> GHC.Types.True } }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell_$c> :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.False
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c> a2 b2
                                  GHC.Types.GT -> GHC.Types.True }
                             GHC.Types.GT -> GHC.Types.True } } }
                        Lib.Indent -> GHC.Types.False }
                   Lib.Indent
                   -> case b of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.True
                        Lib.Indent -> GHC.Types.False } }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell_$c>= :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.False
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$c>= a2 b2
                                  GHC.Types.GT -> GHC.Types.True }
                             GHC.Types.GT -> GHC.Types.True } } }
                        Lib.Indent -> GHC.Types.False }
                   Lib.Indent -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell_$ccompare :: Lib.Cell -> Lib.Cell -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Cell a1 a2
                   -> case b of wild1 {
                        Lib.Cell b1 b2
                        -> case a1 of ww { (,) ww1 ww2 ->
                           case b1 of ww3 { (,) ww4 ww5 ->
                           case GHC.Integer.Type.compareInteger ww1 ww4 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> case GHC.Integer.Type.compareInteger ww2 ww5 of wild3 {
                                  GHC.Types.LT -> GHC.Types.LT
                                  GHC.Types.EQ -> GHC.Classes.$fOrdChar_$ccompare a2 b2
                                  GHC.Types.GT -> GHC.Types.GT }
                             GHC.Types.GT -> GHC.Types.GT } } }
                        Lib.Indent -> GHC.Types.LT }
                   Lib.Indent
                   -> case b of wild1 {
                        Lib.Cell ipv ipv1 -> GHC.Types.GT
                        Lib.Indent -> GHC.Types.EQ } }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell_$cmax :: Lib.Cell -> Lib.Cell -> Lib.Cell
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: Lib.Cell) (y :: Lib.Cell) ->
                 case Lib.$fOrdCell_$c<= x1 y of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> y }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fOrdCell_$cmin :: Lib.Cell -> Lib.Cell -> Lib.Cell
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: Lib.Cell) (y :: Lib.Cell) ->
                 case Lib.$fOrdCell_$c<= x1 y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x1 }) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fShowCell :: GHC.Show.Show Lib.Cell
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Cell
                  Lib.$fShowCell_$cshowsPrec
                  Lib.$fShowCell_$cshow
                  Lib.$fShowCell_$cshowList -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fShowCell1 :: Lib.Cell -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Lib.$fShowCell_$cshowsPrec Lib.$fShowCell2) -}
01fecb7968a1b89cbfb8764bfeb0d0e0
  $fShowCell2 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
04fcff603119bd0c3a2042ef59ce6259
  $fShowCell3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Indent"#) -}
18af5d30d6c8e2c7b34aae06fd0bfb33
  $fShowCell4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Cell "#) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fShowCell_$cshow :: Lib.Cell -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Lib.Cell) ->
                 Lib.$fShowCell_$cshowsPrec
                   GHC.Show.shows22
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fShowCell_$cshowList :: [Lib.Cell] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Cell Lib.$fShowCell1) -}
baa386c6efd40b5f3cc6bb5e664afd33
  $fShowCell_$cshowsPrec ::
    GHC.Types.Int -> Lib.Cell -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (a :: GHC.Types.Int)
                   (ds :: Lib.Cell)
                   (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Lib.Cell b1 b2
                   -> case a of wild1 { GHC.Types.I# x1 ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x2 :: GHC.Base.String)[OneShot] ->
                          case b1 of ww { (,) ww1 ww2 ->
                          GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows7
                            (case GHC.Show.$w$cshowsPrec1
                                    0#
                                    ww1
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.shows5
                                       (GHC.Show.$fShow(,)_$sgo
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.shows4
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.showSpace1
                                                (case b2 of ww4 { GHC.Types.C# ww5 ->
                                                 case ww5 of ds1 {
                                                   DEFAULT
                                                   -> GHC.Types.:
                                                        @ GHC.Types.Char
                                                        GHC.Show.shows14
                                                        (GHC.Show.$wshowLitChar
                                                           ds1
                                                           (GHC.Types.:
                                                              @ GHC.Types.Char
                                                              GHC.Show.shows14
                                                              x2))
                                                   '\''#
                                                   -> GHC.Base.++
                                                        @ GHC.Types.Char
                                                        GHC.Show.shows13
                                                        x2 } })))
                                          (\ (w2 :: GHC.Base.String) ->
                                           case GHC.Show.$w$cshowsPrec1
                                                  0#
                                                  ww2
                                                  w2 of ww4 { (#,#) ww3 ww5 ->
                                           GHC.Types.: @ GHC.Types.Char ww3 ww5 })
                                          (GHC.Types.[]
                                             @ GHC.Show.ShowS))) of ww4 { (#,#) ww3 ww5 ->
                             GHC.Types.: @ GHC.Types.Char ww3 ww5 }) }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x1 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowCell4 (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Lib.$fShowCell4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 eta))) } }
                   Lib.Indent
                   -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowCell3 eta }) -}
fb14b325adc3ac9807f881dbfc004da8
  $fShowGame :: GHC.Show.Show Lib.Game
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Game
                  Lib.$fShowGame_$cshowsPrec
                  Lib.$fShowGame_$cshow
                  Lib.$fShowGame_$cshowList -}
fb14b325adc3ac9807f881dbfc004da8
  $fShowGame1 :: Lib.Game -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 ->
                 Lib.$w$cshowsPrec 0# ww1 ww2 }) -}
fb14b325adc3ac9807f881dbfc004da8
  $fShowGame_$cshow :: Lib.Game -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Lib.Game) ->
                 Lib.$fShowGame_$cshowsPrec
                   GHC.Show.shows22
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fb14b325adc3ac9807f881dbfc004da8
  $fShowGame_$cshowList :: [Lib.Game] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Game Lib.$fShowGame1) -}
fb14b325adc3ac9807f881dbfc004da8
  $fShowGame_$cshowsPrec ::
    GHC.Types.Int -> Lib.Game -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Game) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Game ww3 ww4 ->
                 Lib.$w$cshowsPrec ww1 ww3 ww4 } }) -}
63a6022029ba6a3cabd2296995c95c60
  $s$fShowMap_$cshowsPrec1 :: GHC.Show.Show [Lib.Cell]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Lib.$s$fShowMap_$cshowsPrec_$s$fShow[] -}
2dae488d6d5c23a3ecf3dc265252bb53
  $s$fShowMap_$cshowsPrec_$s$fShowMaybe ::
    GHC.Show.Show (GHC.Base.Maybe [Lib.Cell])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe [Lib.Cell])
                  (GHC.Show.$fShowMaybe_$cshowsPrec
                     @ [Lib.Cell]
                     Lib.$s$fShowMap_$cshowsPrec1)
                  (GHC.Show.$fShowMaybe_$cshow
                     @ [Lib.Cell]
                     Lib.$s$fShowMap_$cshowsPrec1)
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShowMaybe_$cshowList -}
523977fe65b2f0008321c8f3d9ff2cb1
  $s$fShowMap_$cshowsPrec_$s$fShowMaybe_$cshowList ::
    [GHC.Base.Maybe [Lib.Cell]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [GHC.Base.Maybe [Lib.Cell]])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Base.Maybe [Lib.Cell])
                   (GHC.Show.$fShowMaybe_$cshowsPrec
                      @ [Lib.Cell]
                      Lib.$s$fShowMap_$cshowsPrec1
                      GHC.Show.shows22)
                   eta
                   eta1) -}
124b747152a0a66700bc11c2ca443844
  $s$fShowMap_$cshowsPrec_$s$fShow[] :: GHC.Show.Show [Lib.Cell]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [Lib.Cell]
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowsPrec
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshow
                  Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowList -}
2ce0cb938c0319bafd0fca106a17380d
  $s$fShowMap_$cshowsPrec_$s$fShow[]_$cshow ::
    [Lib.Cell] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: [Lib.Cell]) ->
                 Lib.$fShowCell_$cshowList x1 (GHC.Types.[] @ GHC.Types.Char)) -}
af89bf3fbe9ae7724b0b86fd11ba574b
  $s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowList ::
    [[Lib.Cell]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [[Lib.Cell]]) (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ [Lib.Cell]
                   Lib.$fShowCell_$cshowList
                   eta
                   eta1) -}
62d2a9cf95abdd2ef8b08eebdca49566
  $s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowsPrec ::
    GHC.Types.Int -> [Lib.Cell] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Int)
                   (eta :: [Lib.Cell])
                   (eta1 :: GHC.Base.String) ->
                 Lib.$fShowCell_$cshowList eta eta1) -}
a2d2a26fd9675cc85a15ffd61d171952
  $sfromList ::
    [(GHC.Base.String, a)] -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(GHC.Base.String, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ GHC.Base.String @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x1 ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Base.Bin
                             @ GHC.Base.String
                             @ a
                             1#
                             dt
                             x1
                             (Data.Map.Base.Tip @ GHC.Base.String @ a)
                             (Data.Map.Base.Tip @ GHC.Base.String @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$s$ccompare1 kx ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                Lib.$sfromList1
                                  @ a
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x1
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a))
                                  wild2 }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                Lib.$wpoly_go10
                                  @ a
                                  1#
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x1
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a))
                                  wild2 } } } } } }) -}
1c27c18469af1031215e89a324628d69
  $sfromList1 ::
    Data.Map.Base.Map GHC.Base.String a1
    -> [(GHC.Base.String, a1)] -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
1fa988e762b566c46176f46d5a8f375a
  $sinsert_$sgo10 ::
    GHC.Base.String
    -> a1
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
c637d1fa84a03af5839c3b94157ca003
  $smember1 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
fcc926dddc930b56dffffd8ac438d3b3
  $tc'Cell :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14207714437241745227##
                   15401806165526691094##
                   Lib.$trModule
                   Lib.$tc'Cell1) -}
2fcc73212eae5712693f80473e0c2ab5
  $tc'Cell1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Cell"#) -}
59629c81bdb43c9c0e442d5e6eb536f4
  $tc'Game :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5869054354299377495##
                   7321233927434792299##
                   Lib.$trModule
                   Lib.$tc'Game1) -}
a4b969bc1ba40e377113627eac421664
  $tc'Game1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Game"#) -}
8f2a0386549a1ec4c25adfc6b31f0a69
  $tc'Indent :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5142131740241892309##
                   6031865417566924963##
                   Lib.$trModule
                   Lib.$tc'Indent1) -}
c15e4389af8c0b3ebce056d200da836f
  $tc'Indent1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Indent"#) -}
c5958f4ebbdfd51ee9b5baa4b2cbd924
  $tcCell :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9885011101370466894##
                   15093775846094004099##
                   Lib.$trModule
                   Lib.$tcCell1) -}
6b359bf410cb93d80e0d7491168c19cf
  $tcCell1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Cell"#) -}
d2c81a2faa8d42618dcabe5fab3d345b
  $tcGame :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15744468633948233114##
                   704894363175240569##
                   Lib.$trModule
                   Lib.$tcGame1) -}
c38b7592137c64fd1488f9ddddc59bae
  $tcGame1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Game"#) -}
6de8425ed4783304ed2c7b643eeac2fe
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
f5ccc0a83a62c1cd18ffcca711a461c4
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
051fbe1ffca588dd4de7aeb3550a1562
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "words-0.1.0.0-LISqhhIiZ4617lGqKY5VXc"#) -}
95575fc25365ce64af0a01b2a5b34184
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Lib.Grid Lib.Cell
    -> Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,U><L,1*U>, Inline: [0] -}
e49f0d35353831e467ab69aeec2ee06c
  $wcompleted ::
    Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: Data.Map.Base.Map
                            GHC.Base.String (GHC.Base.Maybe [Lib.Cell])) ->
                 case GHC.List.$wlenAcc
                        @ [Lib.Cell]
                        (Data.Maybe.catMaybes1
                           @ [Lib.Cell]
                           (Data.Map.Base.elems
                              @ [GHC.Types.Char]
                              @ (GHC.Base.Maybe [Lib.Cell])
                              ww))
                        0# of ww2 { DEFAULT ->
                 case Lib.completed_go10
                        (GHC.Base.id @ GHC.Types.Int)
                        ww
                        Lib.$fShowCell2 of wild1 { GHC.Types.I# y ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ww2 y) } }) -}
75ea8c5a9a956643bf9c6d902c8aa456
  $wformatGame ::
    Lib.Grid Lib.Cell
    -> Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: Lib.Grid Lib.Cell)
                   (ww1 :: Data.Map.Base.Map
                             GHC.Base.String (GHC.Base.Maybe [Lib.Cell])) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Data.OldList.unlines
                      (GHC.Base.map @ [Lib.Cell] @ [GHC.Types.Char] Lib.formatGame1 ww))
                   (GHC.CString.unpackAppendCString#
                      "\n\
                      \\n"#
                      (case GHC.List.$wlenAcc
                              @ [Lib.Cell]
                              (Data.Maybe.catMaybes1
                                 @ [Lib.Cell]
                                 (Data.Map.Base.elems
                                    @ [GHC.Types.Char]
                                    @ (GHC.Base.Maybe [Lib.Cell])
                                    ww1))
                              0# of ww2 { DEFAULT ->
                       case GHC.Show.$wshowSignedInt
                              0#
                              ww2
                              (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                       GHC.Base.++
                         @ GHC.Types.Char
                         (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                         (GHC.CString.unpackAppendCString#
                            "/"#
                            (case Lib.completed_go10
                                    (GHC.Base.id @ GHC.Types.Int)
                                    ww1
                                    Lib.$fShowCell2 of ww3 { GHC.Types.I# ww7 ->
                             case GHC.Show.$wshowSignedInt
                                    0#
                                    ww7
                                    (GHC.Types.[] @ GHC.Types.Char) of ww8 { (#,#) ww9 ww10 ->
                             GHC.Types.: @ GHC.Types.Char ww9 ww10 } })) } }))) -}
01f4c122258dcf032594b8cb2047842e
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Base.String a
    -> [(GHC.Base.String, a)]
    -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
baa386c6efd40b5f3cc6bb5e664afd33
  data Cell
    = Cell (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
           GHC.Types.Char
    | Indent
fb14b325adc3ac9807f881dbfc004da8
  data Game
    = Game {gameGrid :: Lib.Grid Lib.Cell,
            gameWords :: Data.Map.Base.Map
                           GHC.Base.String (GHC.Base.Maybe [Lib.Cell])}
998714286f71a015d86f7edf8ab38df9
  type Grid a = [[a]]
b56435b75b7945083b5bddd58f3bef5e
  cell2char :: Lib.Cell -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Cell) ->
                 case ds of wild {
                   Lib.Cell ds1 c -> c Lib.Indent -> Lib.cell2char1 }) -}
07250d13878d3feffb46e8a5d1de9311
  cell2char1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '?'#) -}
2e1f1155e4e87a93f88f5c537c7efb31
  completed :: Lib.Game -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 -> Lib.$wcompleted ww2 }) -}
1a7ec1d511599c26a224424144c10668
  completed_go10 ::
    (GHC.Types.Int -> GHC.Types.Int)
    -> Data.Map.Base.Map [GHC.Types.Char] (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
cdbe819f9e7a4c4bb4b46f5a3a1bb53c
  fillInBlanks ::
    System.Random.RandomGen t =>
    t -> Lib.Grid GHC.Types.Char -> Lib.Grid GHC.Types.Char
  {- Arity: 3,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U,U)),C(U(U,U)))><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   ($dRandomGen :: System.Random.RandomGen t)
                   (gen :: t)
                   (grid :: Lib.Grid GHC.Types.Char) ->
                 GHC.Base.build
                   @ [GHC.Types.Char]
                   (\ @ b1
                      (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.List.zipWithFB
                         @ [GHC.Types.Char]
                         @ b1
                         @ b1
                         @ [GHC.Types.Char]
                         @ [GHC.Types.Char]
                         c1
                         (GHC.List.zipWith
                            @ GHC.Types.Char
                            @ GHC.Types.Char
                            @ GHC.Types.Char
                            Lib.fillInBlanks1))
                      n
                      grid
                      (Lib.makeRandomGrid @ t $dRandomGen gen))) -}
d93f568817e353fe3654e021900985fe
  fillInBlanks1 :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Char
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Types.Char) (r :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# ds1 ->
                 case ds1 of ds2 {
                   DEFAULT
                   -> case r of wild1 { GHC.Types.C# ds3 ->
                      case ds3 of ds4 { DEFAULT -> Lib.fillInBlanks2 '_'# -> wild } }
                   '_'# -> r } }) -}
58cde79c6db2c192ef69700658def9ac
  fillInBlanks2 :: GHC.Types.Char
  {- Strictness: x -}
6aaf93ca103fab14794c9baeba81b116
  findWord ::
    Lib.Grid Lib.Cell -> GHC.Base.String -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (grid :: Lib.Grid Lib.Cell)
                   (word :: GHC.Base.String) ->
                 let {
                   lines :: [[Lib.Cell]]
                   = GHC.Base.++
                       @ [Lib.Cell]
                       grid
                       (GHC.Base.++
                          @ [Lib.Cell]
                          (Data.OldList.transpose @ Lib.Cell grid)
                          (GHC.Base.++
                             @ [Lib.Cell]
                             (Data.OldList.transpose @ Lib.Cell (Lib.skew grid))
                             (Data.OldList.transpose
                                @ Lib.Cell
                                (Lib.skew
                                   (GHC.Base.map
                                      @ [Lib.Cell]
                                      @ [Lib.Cell]
                                      (GHC.List.reverse @ Lib.Cell)
                                      grid)))))
                 } in
                 let {
                   z :: [GHC.Base.Maybe [Lib.Cell]]
                   = GHC.Base.map
                       @ [Lib.Cell]
                       @ (GHC.Base.Maybe [Lib.Cell])
                       (\ (x1 :: [Lib.Cell]) ->
                        Lib.findWordInLine word (GHC.List.reverse @ Lib.Cell x1))
                       lines
                 } in
                 letrec {
                   go :: [[Lib.Cell]] -> [GHC.Base.Maybe [Lib.Cell]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[Lib.Cell]]) ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> GHC.Types.:
                            @ (GHC.Base.Maybe [Lib.Cell])
                            (Lib.findWordInLine word y)
                            (go ys) }
                 } in
                 case Data.Maybe.catMaybes1 @ [Lib.Cell] (go lines) of wild {
                   [] -> GHC.Base.Nothing @ [Lib.Cell]
                   : a1 ds1 -> GHC.Base.Just @ [Lib.Cell] a1 }) -}
8bd6004b1eb1971e1b9abca5d643288d
  findWordInCellLinePrefix ::
    [Lib.Cell]
    -> GHC.Base.String -> [Lib.Cell] -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,1*U> -}
3fe3289547f1d5402cfbece30d8e991c
  findWordInLine ::
    GHC.Base.String -> [Lib.Cell] -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
b3daa7299c461778f51a50b38d5b7533
  findWords ::
    Lib.Grid Lib.Cell -> [GHC.Base.String] -> GHC.Base.Maybe [Lib.Cell]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (grid :: Lib.Grid Lib.Cell)
                   (words :: [GHC.Base.String]) ->
                 case Data.Maybe.catMaybes1
                        @ [Lib.Cell]
                        (GHC.Base.map
                           @ [GHC.Types.Char]
                           @ (GHC.Base.Maybe [Lib.Cell])
                           (Lib.findWord grid)
                           words) of wild {
                   [] -> GHC.Base.Nothing @ [Lib.Cell]
                   : a1 ds1 -> GHC.Base.Just @ [Lib.Cell] a1 }) -}
3821c1c35c221c4f4f29faa06b6b673f
  formatGame :: Lib.Game -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 -> Lib.$wformatGame ww1 ww2 }) -}
2b1e602b66b8fcd971458a29a22d06b7
  formatGame1 :: [Lib.Cell] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.Base.map
                   @ Lib.Cell
                   @ GHC.Types.Char
                   Lib.cell2char) -}
14401ad97c2c9b5a6246481cfcb3f985
  formatGrid :: Lib.Grid Lib.Cell -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Lib.Grid Lib.Cell) ->
                 Data.OldList.unlines
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         (c :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ [Lib.Cell]
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ [Lib.Cell]
                            c
                            Lib.formatGame1)
                         n
                         x1))) -}
d7ea327216f01ef9b15f59c7219ad601
  gameGrid :: Lib.Game -> Lib.Grid Lib.Cell
  RecSel Left Lib.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Game) ->
                 case ds of wild { Lib.Game ds1 ds2 -> ds1 }) -}
3af8403a7af907440ae7fddfd6f4e00b
  gameWords ::
    Lib.Game
    -> Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
  RecSel Left Lib.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Game) ->
                 case ds of wild { Lib.Game ds1 ds2 -> ds2 }) -}
296ad0b6a437a6687f888ff1394a54cd
  gridWithCoords :: Lib.Grid GHC.Types.Char -> Lib.Grid Lib.Cell
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [[GHC.Types.Char]]) ->
                 GHC.Base.build
                   @ [Lib.Cell]
                   (\ @ b1
                      (c1 :: [Lib.Cell] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.List.zipWithFB
                         @ [Lib.Cell]
                         @ b1
                         @ b1
                         @ [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                         @ [GHC.Types.Char]
                         c1
                         (GHC.List.zipWith
                            @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                            @ GHC.Types.Char
                            @ Lib.Cell
                            Lib.Cell))
                      n
                      Lib.gridWithCoords1
                      eta)) -}
8acf8fc9a818c6d4a7939a96d64def71
  gridWithCoords1 ::
    [[(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]]
  {- Unfolding: (Lib.gridWithCoords_go
                   Lib.gridWithCoords2
                   Lib.gridWithCoords_xs) -}
4ff0b47606ea22f6590b1a1723509de3
  gridWithCoords2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
e868d733229b4ab867b96f643f4a7ce7
  gridWithCoords_go ::
    GHC.Integer.Type.Integer
    -> [[GHC.Integer.Type.Integer]]
    -> [[(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
5d34efd57e9afc782ad67466bd2b233b
  gridWithCoords_xs :: [[GHC.Integer.Type.Integer]]
97cfb2e6795db37e7a3af92a4af10889
  makeGame ::
    Lib.Grid GHC.Types.Char -> [GHC.Base.String] -> Lib.Game
  {- Arity: 2, Strictness: <L,1*U><L,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid GHC.Types.Char)
                   (words :: [GHC.Base.String]) ->
                 Lib.Game
                   (Lib.gridWithCoords grid)
                   (Lib.$sfromList
                      @ (GHC.Base.Maybe [Lib.Cell])
                      (GHC.Base.build
                         @ (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
                         (\ @ b1
                            (c :: (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
                                  -> b1 -> b1)[OneShot]
                            (n :: b1)[OneShot] ->
                          GHC.Base.foldr
                            @ [GHC.Types.Char]
                            @ b1
                            (GHC.Base.mapFB
                               @ (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
                               @ b1
                               @ [GHC.Types.Char]
                               c
                               Lib.makeGame1)
                            n
                            words)))) -}
aa6b71832227b06d20f39a30f304c7bb
  makeGame1 ::
    GHC.Base.String -> (GHC.Base.String, GHC.Base.Maybe [Lib.Cell])
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (word :: GHC.Base.String) ->
                 (word, GHC.Base.Nothing @ [Lib.Cell])) -}
f99a4faf93bb300488c15be1e99abcf1
  makeRandomGrid ::
    System.Random.RandomGen t => t -> [[GHC.Types.Char]]
  {- Arity: 2,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U,U)),C(U(U,U)))><L,U>,
     Unfolding: (\ @ t
                   ($dRandomGen :: System.Random.RandomGen t)
                   (eta :: t) ->
                 letrec {
                   go :: t -> [GHC.Types.Char] {- Arity: 1, Strictness: <L,U> -}
                   = \ (g2 :: t) ->
                     case System.Random.$wrandomIvalInteger
                            @ t
                            @ GHC.Types.Int
                            $dRandomGen
                            GHC.Num.$fNumInt
                            Lib.makeRandomGrid2
                            Lib.makeRandomGrid1
                            g2 of ww7 { (#,#) ww8 ww9 ->
                     case ww8 of wild { GHC.Types.I# i# ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111##) of wild1 {
                       GHC.Types.False
                       -> case GHC.Char.chr2 i# ret_ty [GHC.Types.Char] of {}
                       GHC.Types.True
                       -> GHC.Types.:
                            @ GHC.Types.Char
                            (GHC.Types.C# (GHC.Prim.chr# i#))
                            (go ww9) } } }
                 } in
                 letrec {
                   makeRandomGrid3 :: t -> [[GHC.Types.Char]]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (gen :: t) ->
                     let {
                       ds :: (t, t) = System.Random.split @ t $dRandomGen gen
                     } in
                     GHC.Types.:
                       @ [GHC.Types.Char]
                       (go (case ds of wild { (,) gen1 gen2 -> gen1 }))
                       (makeRandomGrid3 (case ds of wild { (,) gen1 gen2 -> gen2 }))
                 } in
                 makeRandomGrid3 eta) -}
2a0e3d5f8fd226f7aa832c18a3d60b9c
  makeRandomGrid1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (90) -}
afb3b509889ee7b8f1584d0f581f93e9
  makeRandomGrid2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (65) -}
38f32919136a14ddee7bf8818340739f
  outputGrid :: Lib.Grid Lib.Cell -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.outputGrid1
                  `cast`
                (<Lib.Grid Lib.Cell>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
9f917f083a3d8dd4872914383fe837d3
  outputGrid1 ::
    Lib.Grid Lib.Cell
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (grid :: Lib.Grid Lib.Cell)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Lib.formatGrid grid)
                   GHC.Types.True
                   eta) -}
0b177a91e6435ea7607e39531b662a55
  playGame :: Lib.Game -> GHC.Base.String -> Lib.Game
  {- Arity: 2, Strictness: <S(LS),1*U(U,U)><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Game) (w1 :: GHC.Base.String) ->
                 case w of ww { Lib.Game ww1 ww2 ->
                 case Lib.$smember1 @ (GHC.Base.Maybe [Lib.Cell]) w1 ww2 of wild {
                   GHC.Types.False -> Lib.Game ww1 ww2
                   GHC.Types.True
                   -> case Lib.findWord ww1 w1 of wild1 {
                        GHC.Base.Nothing -> Lib.Game ww1 ww2
                        GHC.Base.Just cs
                        -> Lib.Game
                             ww1
                             (Lib.$sinsert_$sgo10
                                @ (GHC.Base.Maybe [Lib.Cell])
                                w1
                                wild1
                                ww2) } } }) -}
be5821fe66f20219b5a273474bd7643a
  score :: Lib.Game -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Game) ->
                 case w of ww { Lib.Game ww1 ww2 ->
                 case GHC.List.$wlenAcc
                        @ [Lib.Cell]
                        (Data.Maybe.catMaybes1
                           @ [Lib.Cell]
                           (Data.Map.Base.elems
                              @ [GHC.Types.Char]
                              @ (GHC.Base.Maybe [Lib.Cell])
                              ww2))
                        0# of ww3 { DEFAULT ->
                 GHC.Types.I# ww3 } }) -}
624d613e608f8f0620fcf28e21aac5c4
  skew :: Lib.Grid Lib.Cell -> Lib.Grid Lib.Cell
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f7d8941b52df9453a5f443f4786248ed
  totalWords :: Lib.Game -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (game :: Lib.Game) ->
                 case game of wild { Lib.Game ds ds1 -> Lib.totalWords1 ds1 }) -}
a8261089cf31ff03cc29255a44d06ca4
  totalWords1 ::
    Data.Map.Base.Map GHC.Base.String (GHC.Base.Maybe [Lib.Cell])
    -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (x1 :: Data.Map.Base.Map
                            GHC.Base.String (GHC.Base.Maybe [Lib.Cell])) ->
                 Lib.completed_go10
                   (GHC.Base.id @ GHC.Types.Int)
                   x1
                   Lib.$fShowCell2) -}
db0fe5e8a91518e3772a44c73c9417af
  zipOverGrid :: Lib.Grid a -> Lib.Grid b -> Lib.Grid (a, b)
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ @ a @ b ->
                 GHC.List.zipWith @ [a] @ [b] @ [(a, b)] (GHC.List.zip @ a @ b)) -}
0220c2ac795f0dc014fb22a97ec650ec
  zipOverGridWith ::
    (a -> b -> c) -> Lib.Grid a -> Lib.Grid b -> Lib.Grid c
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (x1 :: a -> b -> c)
                   (eta :: [[a]])
                   (eta1 :: [[b]]) ->
                 GHC.Base.build
                   @ [c]
                   (\ @ b1 (c1 :: [c] -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ [a]
                      @ [b]
                      @ b1
                      (GHC.List.zipWithFB
                         @ [c]
                         @ b1
                         @ b1
                         @ [a]
                         @ [b]
                         c1
                         (GHC.List.zipWith @ a @ b @ c x1))
                      n
                      eta
                      eta1)) -}
instance [safe] GHC.Classes.Eq [Lib.Cell] = Lib.$fEqCell
instance [safe] GHC.Classes.Ord [Lib.Cell] = Lib.$fOrdCell
instance [safe] GHC.Show.Show [Lib.Cell] = Lib.$fShowCell
instance [safe] GHC.Show.Show [Lib.Game] = Lib.$fShowGame
"SPEC/Lib $fShowMaybe @ [Cell]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                             [Lib.Cell])
  GHC.Show.$fShowMaybe @ [Lib.Cell] $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShowMaybe
"SPEC/Lib $fShowMaybe_$cshowList @ [Cell]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                        [Lib.Cell])
  GHC.Show.$fShowMaybe_$cshowList @ [Lib.Cell] $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShowMaybe_$cshowList
"SPEC/Lib $fShow[] @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Lib.Cell)
  GHC.Show.$fShow[] @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]
"SPEC/Lib $fShow[]_$cshow @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                               Lib.Cell)
  GHC.Show.$fShow[]_$cshow @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshow
"SPEC/Lib $fShow[]_$cshowList @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                   Lib.Cell)
  GHC.Show.$fShow[]_$cshowList @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowList
"SPEC/Lib $fShow[]_$cshowsPrec @ Cell" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                    Lib.Cell)
  GHC.Show.$fShow[]_$cshowsPrec @ Lib.Cell $dShow
  = Lib.$s$fShowMap_$cshowsPrec_$s$fShow[]_$cshowsPrec
"SPEC/Lib fromList @ String _" [ALWAYS] forall @ a
                                               ($dOrd :: GHC.Classes.Ord GHC.Base.String)
  Data.Map.Base.fromList @ [GHC.Types.Char] @ a $dOrd
  = Lib.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

